#include "app_key.h"
#include "gpio_8258.h"
#include "work_pattern.h"
#include "massage_system.h"
#include "tuya_ble_log.h"
#include "drivers.h"
#include "voice_prompt.h"
#include "temp_check.h"
#include "tuya_ble_api.h"
#include "power_memory.h"

unsigned char key_buf = 0;
unsigned char key_old = 0;
unsigned char key_delay_cont = 0;

unsigned char key_trg = 0x00;
unsigned char key_cont = 0x00;

unsigned long sys_time = 0;
extern uint8_t app_flag;
//{DP_ID, DP_type, DP_len, DP_data}
unsigned char gear_buf[]   = {0x67, 0x04, 0x01, 0x00};	// gear
unsigned char mode_buf[]   = {0x68, 0x04, 0x01, 0x00};	// mode
unsigned char heat_buf[]   = {0x66, 0x04, 0x01, 0x01};	// heat
unsigned char switch_buf[] = {0x69, 0x01, 0x01, 0x00};	// switch

//所有按键初始化，按键低电平有效
void user_button_init(void)
{
	gpio_set_func(LED_1, AS_GPIO);
	gpio_set_output_en(LED_1, 1);
	gpio_write(LED_1, 1);

    gpio_set_func(KEY_1 | KEY_2 | KEY_3 | KEY_4 | KEY_5, AS_GPIO);
    gpio_set_input_en(KEY_1, 1);
    gpio_set_input_en(KEY_2, 1);
    gpio_set_input_en(KEY_3, 1);
    gpio_set_input_en(KEY_4, 1);
    gpio_set_input_en(KEY_5, 1);

    gpio_setup_up_down_resistor(KEY_1, PM_PIN_PULLUP_10K);
    gpio_setup_up_down_resistor(KEY_2, PM_PIN_PULLUP_10K);
    gpio_setup_up_down_resistor(KEY_3, PM_PIN_PULLUP_10K);
    gpio_setup_up_down_resistor(KEY_4, PM_PIN_PULLUP_10K);
    gpio_setup_up_down_resistor(KEY_5, PM_PIN_PULLUP_10K);

    return;
}

void app_key_scan(unsigned char *trg,unsigned char *cont)
{
	int i;
    unsigned char read_data = 0x00;
    if (KEY_RELEAS_LEVEL) {
        read_data = 0x1F;
    }else {
        read_data = 0x00;
    }
    uint8_t key[5] = {gpio_read(KEY_1),
    		          gpio_read(KEY_2),		//gpio_read() 返回一个大于1的数
    		          gpio_read(KEY_3),
    		          gpio_read(KEY_4),
    		          gpio_read(KEY_5)
    				 };
    for (i = 0; i < 5; i++) {
        if (key[i]) {
        	key[i] = 1;
        } else {
        	key[i] = 0;
        }
    }
    read_data = (key[0] << 4) | (key[1] << 3) | (key[2] << 2) | (key[3] << 1) | (key[4]);
    *trg = (read_data & (read_data ^ (*cont)));
    *cont = read_data;
}

static void my_key_event(unsigned char key_event)
{
	uint8_t sb_data = 0;
    switch(key_event)
    {
    case KEY_CODE_SWITCH:
    	if(!massage_state.on_off) {
    		break;
    	}
		TUYA_APP_LOG_DEBUG(" massage_state.pattern:%d",  massage_state.pattern);
		sb_data = massage_state.pattern + 21;
		mode_buf[3] = massage_state.pattern;
    	if (app_flag) {
    		tuya_ble_dp_data_report(mode_buf, 4);
    	}
    	massage_state.pattern++;
		if (massage_state.pattern > 4) {
			massage_state.pattern = 0;
		}
		voice_playing(sb_data);
		write_massage_status_to_flash();

    	break;
    case KEY_HEAT_STRONG:
    	if(!massage_state.on_off) {
    		break;
    	}
		massage_state.heat = strong_heat;
		TUYA_APP_LOG_DEBUG("massage_state.heat:%d", massage_state.heat);
    	switching_heat(massage_state.heat);
    	heat_buf[3] = massage_state.heat;
    	if (app_flag) {		//Reporting of operations generated by the device in the power-on state only
    		tuya_ble_dp_data_report(heat_buf, 4);	//Reported data after status change
    	}
		voice_playing(2);
		write_massage_status_to_flash();		//Write the current heating level to flash

    	break;
    case KEY_MODE_LOW:
    	if(!massage_state.on_off) {
    		break;
    	}
		if (massage_state.gear > 0) {
			massage_state.gear--;
		}
		TUYA_APP_LOG_INFO("gear:%d", massage_state.gear + 1);
		switching_gear(massage_state.gear);
		gear_buf[3] = massage_state.gear;
		if (app_flag) {
		    tuya_ble_dp_data_report(gear_buf, 4);
		}
		sb_data = massage_state.gear + 5;
		voice_playing(sb_data);
		write_massage_status_to_flash();

    	break;
    case KEY_MODE_ADD:
    	if(!massage_state.on_off) {
    		break;
    	}
		massage_state.gear++;
		if (massage_state.gear > 15) {
			massage_state.gear = 15;
		}
		TUYA_APP_LOG_INFO("gear:%d", massage_state.gear + 1);
		switching_gear(massage_state.gear);
		gear_buf[3] = massage_state.gear;
		if (app_flag) {
		   tuya_ble_dp_data_report(gear_buf, 4);
		}
		sb_data = massage_state.gear + 5;
		voice_playing(sb_data);
		write_massage_status_to_flash();
    	break;
    case KEY_HEAT_LOW_OFF:
    	if(!massage_state.on_off) {
    		break;
    	}
		massage_state.heat = off_heat;
		TUYA_APP_LOG_DEBUG("massage_state.heat:%d", massage_state.heat);
    	switching_heat(massage_state.heat);
    	heat_buf[3] = massage_state.heat;
    	if (app_flag) {
    		tuya_ble_dp_data_report(heat_buf, 4);
    	}
		voice_playing(4);

		write_massage_status_to_flash();

    	break;

    }
}

void app_key_poll(void)
{
	if(!clock_time_exceed(sys_time, 20 * TIME_MS)){
		return;
	}
	sys_time = clock_time();

    app_key_scan(&key_trg,&key_cont);

    switch (key_cont)
    {
    case KEY_CODE_RELEASE:

        if(key_buf != 0) {

        	my_key_event(key_buf);
        }

        key_buf = 0;
        key_old = KEY_CODE_RELEASE;

        break;
    case KEY_CODE_SWITCH:

    	if(key_buf == 0xfe)
        {
        	break;
        }

        if(key_buf == 0xff)
        {
        	if(massage_state.on_off) {

                voice_playing(35);
        		TUYA_APP_LOG_INFO("Thanks_for_use!");
        		gpio_write(LED_1, 1);

        		power_off_init();
        		massage_state.on_off = 0;
        		switch_buf[3] = massage_state.on_off;
        		tuya_ble_dp_data_report(switch_buf, 4);
        		app_flag = 0;
            	write_massage_status_to_flash();

        	}else{

        		TUYA_APP_LOG_INFO("welcome_to_use_massage!");
        		gpio_write(LED_1, 0);

        		rs2255_init();
        		voice_prompt_init();

        		pattern_pin_init();
        		massage_state.on_off = 1;
            	voice_playing(1);
        		TUYA_APP_LOG_INFO("massage_state after=%d",massage_state.on_off);
        		switch_buf[3] = massage_state.on_off;
        		tuya_ble_dp_data_report(switch_buf, 4);
        		app_flag = 1;
            	read_massage_status_to_flash();
            	tuya_ble_dp_data_report(gear_buf, 4);
            	tuya_ble_dp_data_report(heat_buf, 4);
            	tuya_ble_dp_data_report(mode_buf, 4);

        	}
        	key_buf = 0xfe;

        	break;
        }

    	app_key_scan(&key_trg,&key_cont);

        if(key_old == KEY_CODE_SWITCH) {

        	key_delay_cont++;
            key_buf = KEY_CODE_SWITCH;

        }else{
        	key_delay_cont = 0;
        }

        if(key_delay_cont >= 2) {
        	key_buf = KEY_CODE_SWITCH;
        }

        if(key_delay_cont >= 50) {
        	key_buf = KEY_LONG_PRESS;
        	key_delay_cont = 0;

        }

        key_old = KEY_CODE_SWITCH;

        break;
    case KEY_HEAT_STRONG:
    	app_key_scan(&key_trg,&key_cont);

        if(key_cont == KEY_HEAT_STRONG) {

            key_buf = KEY_HEAT_STRONG;
        }

        key_old = KEY_HEAT_STRONG;

        break;
    case KEY_MODE_LOW:

    	app_key_scan(&key_trg,&key_cont);

        if(key_cont == KEY_MODE_LOW) {

            key_buf = KEY_MODE_LOW;
        }

        key_old = KEY_MODE_LOW;

        break;
    case KEY_MODE_ADD:

    	app_key_scan(&key_trg,&key_cont);

        if(key_cont == KEY_MODE_ADD) {

            key_buf = KEY_MODE_ADD;
        }

        key_old = KEY_MODE_ADD;

        break;
    case KEY_HEAT_LOW_OFF:

    	app_key_scan(&key_trg,&key_cont);

        if(key_cont == KEY_HEAT_LOW_OFF) {

            key_buf = KEY_HEAT_LOW_OFF;
        }

        key_old = KEY_HEAT_LOW_OFF;

    	break;
    default:
        break;
    }

}
